{
  "language": "Solidity",
  "sources": {
    "@ethereum-attestation-service/eas-contracts/contracts/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// A representation of an empty/uninitialized UID.\nbytes32 constant EMPTY_UID = 0;\n\n// A zero expiration represents an non-expiring attestation.\nuint64 constant NO_EXPIRATION_TIME = 0;\n\nerror AccessDenied();\nerror DeadlineExpired();\nerror InvalidEAS();\nerror InvalidLength();\nerror InvalidSignature();\nerror NotFound();\n\n/// @notice A struct representing ECDSA signature data.\nstruct Signature {\n    uint8 v; // The recovery ID.\n    bytes32 r; // The x-coordinate of the nonce R.\n    bytes32 s; // The signature data.\n}\n\n/// @notice A struct representing a single attestation.\nstruct Attestation {\n    bytes32 uid; // A unique identifier of the attestation.\n    bytes32 schema; // The unique identifier of the schema.\n    uint64 time; // The time when the attestation was created (Unix timestamp).\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint64 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    bytes32 refUID; // The UID of the related attestation.\n    address recipient; // The recipient of the attestation.\n    address attester; // The attester/sender of the attestation.\n    bool revocable; // Whether the attestation is revocable.\n    bytes data; // Custom attestation data.\n}\n\n/// @notice A helper function to work with unchecked iterators in loops.\nfunction uncheckedInc(uint256 i) pure returns (uint256 j) {\n    unchecked {\n        j = i + 1;\n    }\n}\n"
    },
    "@ethereum-attestation-service/eas-contracts/contracts/IEAS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISchemaRegistry } from \"./ISchemaRegistry.sol\";\nimport { ISemver } from \"./ISemver.sol\";\nimport { Attestation, Signature } from \"./Common.sol\";\n\n/// @notice A struct representing the arguments of the attestation request.\nstruct AttestationRequestData {\n    address recipient; // The recipient of the attestation.\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bool revocable; // Whether the attestation is revocable.\n    bytes32 refUID; // The UID of the related attestation.\n    bytes data; // Custom attestation data.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the attestation request.\nstruct AttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the full delegated attestation request.\nstruct DelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n    Signature signature; // The ECDSA signature data.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi attestation request.\nstruct MultiAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi attestation request.\nstruct MultiDelegatedAttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData[] data; // The arguments of the attestation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address attester; // The attesting account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the arguments of the revocation request.\nstruct RevocationRequestData {\n    bytes32 uid; // The UID of the attestation to revoke.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\n/// @notice A struct representing the full arguments of the revocation request.\nstruct RevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the arguments of the full delegated revocation request.\nstruct DelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData data; // The arguments of the revocation request.\n    Signature signature; // The ECDSA signature data.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @notice A struct representing the full arguments of the multi revocation request.\nstruct MultiRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation request.\n}\n\n/// @notice A struct representing the full arguments of the delegated multi revocation request.\nstruct MultiDelegatedRevocationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    RevocationRequestData[] data; // The arguments of the revocation requests.\n    Signature[] signatures; // The ECDSA signatures data. Please note that the signatures are assumed to be signed with increasing nonces.\n    address revoker; // The revoking account.\n    uint64 deadline; // The deadline of the signature/request.\n}\n\n/// @title IEAS\n/// @notice EAS - Ethereum Attestation Service interface.\ninterface IEAS is ISemver {\n    /// @notice Emitted when an attestation has been made.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param uid The UID of the new attestation.\n    /// @param schemaUID The UID of the schema.\n    event Attested(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when an attestation has been revoked.\n    /// @param recipient The recipient of the attestation.\n    /// @param attester The attesting account.\n    /// @param schemaUID The UID of the schema.\n    /// @param uid The UID the revoked attestation.\n    event Revoked(address indexed recipient, address indexed attester, bytes32 uid, bytes32 indexed schemaUID);\n\n    /// @notice Emitted when a data has been timestamped.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event Timestamped(bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Emitted when a data has been revoked.\n    /// @param revoker The address of the revoker.\n    /// @param data The data.\n    /// @param timestamp The timestamp.\n    event RevokedOffchain(address indexed revoker, bytes32 indexed data, uint64 indexed timestamp);\n\n    /// @notice Returns the address of the global schema registry.\n    /// @return The address of the global schema registry.\n    function getSchemaRegistry() external view returns (ISchemaRegistry);\n\n    /// @notice Attests to a specific schema.\n    /// @param request The arguments of the attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attest({\n    ///         schema: \"0facc36681cbe2456019c1b0d1e7bedd6d1d40f6f324bf3dd3a4cef2999200a0\",\n    ///         data: {\n    ///             recipient: \"0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf\",\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    ///             data: \"0xF00D\",\n    ///             value: 0\n    ///         }\n    ///     })\n    function attest(AttestationRequest calldata request) external payable returns (bytes32);\n\n    /// @notice Attests to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated attestation request.\n    /// @return The UID of the new attestation.\n    ///\n    /// Example:\n    ///     attestByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         attester: '0xc5E8740aD971409492b1A63Db8d83025e0Fc427e',\n    ///         deadline: 1673891048\n    ///     })\n    function attestByDelegation(\n        DelegatedAttestationRequest calldata delegatedRequest\n    ) external payable returns (bytes32);\n\n    /// @notice Attests to multiple schemas.\n    /// @param multiRequests The arguments of the multi attestation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttest([{\n    ///         schema: '0x33e9094830a5cba5554d1954310e4fbed2ef5f859ec1404619adea4207f391fd',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x480df4a039efc31b11bfdf491b383ca138b6bde160988222a2a3509c02cee174',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: true,\n    ///             refUID: '0x75bf2ed8dca25a8190c50c52db136664de25b2449535839008ccfdab469b214f',\n    ///             data: '0x12345678',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiAttest(MultiAttestationRequest[] calldata multiRequests) external payable returns (bytes32[] memory);\n\n    /// @notice Attests to multiple schemas using via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi attestation requests. The requests should be\n    ///     grouped by distinct schema ids to benefit from the best batching optimization.\n    /// @return The UIDs of the new attestations.\n    ///\n    /// Example:\n    ///     multiAttestByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             recipient: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n    ///             expirationTime: 1673891048,\n    ///             revocable: true,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x1234',\n    ///             value: 0\n    ///         },\n    ///         {\n    ///             recipient: '0xdEADBeAFdeAdbEafdeadbeafDeAdbEAFdeadbeaf',\n    ///             expirationTime: 0,\n    ///             revocable: false,\n    ///             refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    ///             data: '0x00',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         attester: '0x1D86495b2A7B524D747d2839b3C645Bed32e8CF4',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiAttestByDelegation(\n        MultiDelegatedAttestationRequest[] calldata multiDelegatedRequests\n    ) external payable returns (bytes32[] memory);\n\n    /// @notice Revokes an existing attestation to a specific schema.\n    /// @param request The arguments of the revocation request.\n    ///\n    /// Example:\n    ///     revoke({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0x101032e487642ee04ee17049f99a70590c735b8614079fc9275f9dd57c00966d',\n    ///             value: 0\n    ///         }\n    ///     })\n    function revoke(RevocationRequest calldata request) external payable;\n\n    /// @notice Revokes an existing attestation to a specific schema via the provided ECDSA signature.\n    /// @param delegatedRequest The arguments of the delegated revocation request.\n    ///\n    /// Example:\n    ///     revokeByDelegation({\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: {\n    ///             uid: '0xcbbc12102578c642a0f7b34fe7111e41afa25683b6cd7b5a14caf90fa14d24ba',\n    ///             value: 0\n    ///         },\n    ///         signature: {\n    ///             v: 27,\n    ///             r: '0xb593...7142',\n    ///             s: '0x0f5b...2cce'\n    ///         },\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     })\n    function revokeByDelegation(DelegatedRevocationRequest calldata delegatedRequest) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas.\n    /// @param multiRequests The arguments of the multi revocation requests. The requests should be grouped by distinct\n    ///     schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevoke([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///     },\n    ///     {\n    ///         schema: '0x5ac273ce41e3c8bfa383efe7c03e54c5f0bff29c9f11ef6ffa930fc84ca32425',\n    ///         data: [{\n    ///             uid: '0x053d42abce1fd7c8fcddfae21845ad34dae287b2c326220b03ba241bc5a8f019',\n    ///             value: 0\n    ///         },\n    ///     }])\n    function multiRevoke(MultiRevocationRequest[] calldata multiRequests) external payable;\n\n    /// @notice Revokes existing attestations to multiple schemas via provided ECDSA signatures.\n    /// @param multiDelegatedRequests The arguments of the delegated multi revocation attestation requests. The requests\n    ///     should be grouped by distinct schema ids to benefit from the best batching optimization.\n    ///\n    /// Example:\n    ///     multiRevokeByDelegation([{\n    ///         schema: '0x8e72f5bc0a8d4be6aa98360baa889040c50a0e51f32dbf0baa5199bd93472ebc',\n    ///         data: [{\n    ///             uid: '0x211296a1ca0d7f9f2cfebf0daaa575bea9b20e968d81aef4e743d699c6ac4b25',\n    ///             value: 1000\n    ///         },\n    ///         {\n    ///             uid: '0xe160ac1bd3606a287b4d53d5d1d6da5895f65b4b4bab6d93aaf5046e48167ade',\n    ///             value: 0\n    ///         }],\n    ///         signatures: [{\n    ///             v: 28,\n    ///             r: '0x148c...b25b',\n    ///             s: '0x5a72...be22'\n    ///         },\n    ///         {\n    ///             v: 28,\n    ///             r: '0x487s...67bb',\n    ///             s: '0x12ad...2366'\n    ///         }],\n    ///         revoker: '0x244934dd3e31bE2c81f84ECf0b3E6329F5381992',\n    ///         deadline: 1673891048\n    ///     }])\n    function multiRevokeByDelegation(\n        MultiDelegatedRevocationRequest[] calldata multiDelegatedRequests\n    ) external payable;\n\n    /// @notice Timestamps the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function timestamp(bytes32 data) external returns (uint64);\n\n    /// @notice Timestamps the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was timestamped with.\n    function multiTimestamp(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Revokes the specified bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function revokeOffchain(bytes32 data) external returns (uint64);\n\n    /// @notice Revokes the specified multiple bytes32 data.\n    /// @param data The data to timestamp.\n    /// @return The timestamp the data was revoked with.\n    function multiRevokeOffchain(bytes32[] calldata data) external returns (uint64);\n\n    /// @notice Returns an existing attestation by UID.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return The attestation data members.\n    function getAttestation(bytes32 uid) external view returns (Attestation memory);\n\n    /// @notice Checks whether an attestation exists.\n    /// @param uid The UID of the attestation to retrieve.\n    /// @return Whether an attestation exists.\n    function isAttestationValid(bytes32 uid) external view returns (bool);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getTimestamp(bytes32 data) external view returns (uint64);\n\n    /// @notice Returns the timestamp that the specified data was timestamped with.\n    /// @param data The data to query.\n    /// @return The timestamp the data was timestamped with.\n    function getRevokeOffchain(address revoker, bytes32 data) external view returns (uint64);\n}\n"
    },
    "@ethereum-attestation-service/eas-contracts/contracts/ISchemaRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISemver } from \"./ISemver.sol\";\n\nimport { ISchemaResolver } from \"./resolver/ISchemaResolver.sol\";\n\n/// @notice A struct representing a record for a submitted schema.\nstruct SchemaRecord {\n    bytes32 uid; // The unique identifier of the schema.\n    ISchemaResolver resolver; // Optional schema resolver.\n    bool revocable; // Whether the schema allows revocations explicitly.\n    string schema; // Custom specification of the schema (e.g., an ABI).\n}\n\n/// @title ISchemaRegistry\n/// @notice The interface of global attestation schemas for the Ethereum Attestation Service protocol.\ninterface ISchemaRegistry is ISemver {\n    /// @notice Emitted when a new schema has been registered\n    /// @param uid The schema UID.\n    /// @param registerer The address of the account used to register the schema.\n    /// @param schema The schema data.\n    event Registered(bytes32 indexed uid, address indexed registerer, SchemaRecord schema);\n\n    /// @notice Submits and reserves a new schema\n    /// @param schema The schema data schema.\n    /// @param resolver An optional schema resolver.\n    /// @param revocable Whether the schema allows revocations explicitly.\n    /// @return The UID of the new schema.\n    function register(string calldata schema, ISchemaResolver resolver, bool revocable) external returns (bytes32);\n\n    /// @notice Returns an existing schema by UID\n    /// @param uid The UID of the schema to retrieve.\n    /// @return The schema data members.\n    function getSchema(bytes32 uid) external view returns (SchemaRecord memory);\n}\n"
    },
    "@ethereum-attestation-service/eas-contracts/contracts/ISemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice A semver interface.\ninterface ISemver {\n    /// @notice Returns the full semver contract version.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory);\n}\n"
    },
    "@ethereum-attestation-service/eas-contracts/contracts/resolver/ISchemaResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISemver } from \"../ISemver.sol\";\nimport { Attestation } from \"../Common.sol\";\n\n/// @title ISchemaResolver\n/// @notice The interface of an optional schema resolver.\ninterface ISchemaResolver is ISemver {\n    /// @notice Checks if the resolver can be sent ETH.\n    /// @return Whether the resolver supports ETH transfers.\n    function isPayable() external pure returns (bool);\n\n    /// @notice Processes an attestation and verifies whether it's valid.\n    /// @param attestation The new attestation.\n    /// @return Whether the attestation is valid.\n    function attest(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes multiple attestations and verifies whether they are valid.\n    /// @param attestations The new attestations.\n    /// @param values Explicit ETH amounts which were sent with each attestation.\n    /// @return Whether all the attestations are valid.\n    function multiAttest(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n\n    /// @notice Processes an attestation revocation and verifies if it can be revoked.\n    /// @param attestation The existing attestation to be revoked.\n    /// @return Whether the attestation can be revoked.\n    function revoke(Attestation calldata attestation) external payable returns (bool);\n\n    /// @notice Processes revocation of multiple attestation and verifies they can be revoked.\n    /// @param attestations The existing attestations to be revoked.\n    /// @param values Explicit ETH amounts which were sent with each revocation.\n    /// @return Whether the attestations can be revoked.\n    function multiRevoke(\n        Attestation[] calldata attestations,\n        uint256[] calldata values\n    ) external payable returns (bool);\n}\n"
    },
    "contracts/ListingAttester.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport { IEAS, AttestationRequest, AttestationRequestData } from \"@ethereum-attestation-service/eas-contracts/contracts/IEAS.sol\";\r\nimport { NO_EXPIRATION_TIME, EMPTY_UID } from \"@ethereum-attestation-service/eas-contracts/contracts/Common.sol\";\r\n\r\ncontract ListingAttester {\r\n\tIEAS public immutable _eas;\r\n\tbytes32 public immutable _listingSchemaUID;\r\n\r\n\terror InvalidEAS();\r\n\r\n\tconstructor(IEAS eas, bytes32 listingSchemaUID) {\r\n\t\tif (address(eas) == address(0)) {\r\n\t\t\trevert InvalidEAS();\r\n\t\t}\r\n\r\n\t\t_eas = eas;\r\n\t\t_listingSchemaUID = listingSchemaUID;\r\n\t}\r\n\r\n\tfunction attestListing(\r\n\t\tuint256 listingId,\r\n\t\tstring memory listingName,\r\n\t\taddress seller\r\n\t) external returns (bytes32 attestationUID) {\r\n\t\treturn\r\n\t\t\t_eas.attest(\r\n\t\t\t\tAttestationRequest({\r\n\t\t\t\t\tschema: _listingSchemaUID,\r\n\t\t\t\t\tdata: AttestationRequestData({\r\n\t\t\t\t\t\trecipient: seller,\r\n\t\t\t\t\t\texpirationTime: NO_EXPIRATION_TIME, // No expiration time\r\n\t\t\t\t\t\trevocable: true,\r\n\t\t\t\t\t\trefUID: EMPTY_UID, // No references UI\r\n\t\t\t\t\t\tdata: abi.encode(listingId, listingName, seller),\r\n\t\t\t\t\t\tvalue: 0 // No value/ETH\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t// return 0x0d455486a3dadeacfba5f340fe5bf84d1f6678b2e2af53536acc8a4274626f82;\r\n\t}\r\n}\r\n"
    },
    "contracts/ListingConnectionAttester.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport { IEAS, AttestationRequest, AttestationRequestData } from \"@ethereum-attestation-service/eas-contracts/contracts/IEAS.sol\";\r\nimport { NO_EXPIRATION_TIME, EMPTY_UID } from \"@ethereum-attestation-service/eas-contracts/contracts/Common.sol\";\r\n\r\ncontract ListingConnectionAttester {\r\n\tIEAS public immutable _eas;\r\n\tbytes32 public immutable _listingConnectionSchemaUID;\r\n\r\n\terror InvalidEAS();\r\n\r\n\tconstructor(IEAS eas, bytes32 listingConnectionSchemaUID) {\r\n\t\tif (address(eas) == address(0)) {\r\n\t\t\trevert InvalidEAS();\r\n\t\t}\r\n\r\n\t\t_eas = eas;\r\n\t\t_listingConnectionSchemaUID = listingConnectionSchemaUID;\r\n\t}\r\n\r\n\tfunction attestListingConnection(\r\n\t\tuint256 listingId,\r\n\t\taddress seller,\r\n\t\taddress buyer\r\n\t) external returns (bytes32 attestationUID) {\r\n\t\treturn\r\n\t\t\t_eas.attest(\r\n\t\t\t\tAttestationRequest({\r\n\t\t\t\t\tschema: _listingConnectionSchemaUID,\r\n\t\t\t\t\tdata: AttestationRequestData({\r\n\t\t\t\t\t\trecipient: buyer,\r\n\t\t\t\t\t\texpirationTime: NO_EXPIRATION_TIME, // No expiration time\r\n\t\t\t\t\t\trevocable: true,\r\n\t\t\t\t\t\trefUID: EMPTY_UID, // No references UI\r\n\t\t\t\t\t\tdata: abi.encode(listingId, seller, buyer),\r\n\t\t\t\t\t\tvalue: 0 // No value/ETH\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t// return 0x0d455486a3dadeacfba5f340fe5bf84d1f6678b2e2af53536acc8a4274626f82;\r\n\t}\r\n}\r\n"
    },
    "contracts/Listings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"./ListingAttester.sol\";\r\nimport \"./ListingConnectionAttester.sol\";\r\n\r\ncontract Listings {\r\n\tstruct Listing {\r\n\t\tuint256 id;\r\n\t\tstring name;\r\n\t\taddress seller;\r\n\t\tbytes32 attestationUID;\r\n\t\tstring location;\r\n\t\tstring description;\r\n\t\tuint256 price;\r\n\t\tuint256 beds;\r\n\t\tstring cid;\r\n\t}\r\n\r\n\tuint256 private currentId;\r\n\tmapping(uint256 => bool) public existingIds;\r\n\tListing[] public listings;\r\n\tmapping(uint256 => uint256) public idToIndex;\r\n\tListingAttester public immutable _listingAttester;\r\n\r\n\tmapping(uint256 => mapping(address => bool)) public connectedBuyers;\r\n\tListingConnectionAttester public immutable _listingConnectionAttester;\r\n\r\n\tevent AddListing(address indexed seller, uint256 listingId);\r\n\tevent UpdateListing(\r\n\t\taddress indexed seller,\r\n\t\tuint256 listingId,\r\n\t\tstring newName\r\n\t);\r\n\tevent DeleteListing(address indexed seller, uint256 listingId);\r\n\tevent CreateListingConnection(address indexed buyer, uint256 listingId);\r\n\r\n\terror Listings__NotExistedListingId(uint256 listingId);\r\n\terror Listings__InvalidSeller(address seller);\r\n\terror Listings__BuyerAlreadyConnected(address buyer, uint256 listingId);\r\n\r\n\tmodifier checkExistedListingId(uint256 id) {\r\n\t\tif (!existingIds[id]) {\r\n\t\t\trevert Listings__NotExistedListingId(id);\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isSeller(uint256 id) {\r\n\t\tuint256 index = idToIndex[id];\r\n\t\tif (msg.sender != listings[index].seller) {\r\n\t\t\trevert Listings__InvalidSeller(msg.sender);\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor(address listingAttester, address listingConnectionAttester) {\r\n\t\t_listingAttester = ListingAttester(listingAttester);\r\n\t\t_listingConnectionAttester = ListingConnectionAttester(\r\n\t\t\tlistingConnectionAttester\r\n\t\t);\r\n\t}\r\n\r\n\tfunction addListing(\r\n\t\tstring calldata name,\r\n\t\tstring calldata location,\r\n\t\tstring calldata description,\r\n\t\tuint256 price,\r\n\t\tuint256 beds,\r\n\t\tstring calldata cid\r\n\t) public {\r\n\t\tbytes32 attestationUID = _listingAttester.attestListing(\r\n\t\t\tcurrentId,\r\n\t\t\tname,\r\n\t\t\tmsg.sender\r\n\t\t);\r\n\r\n\t\tListing memory listing = Listing(\r\n\t\t\tcurrentId,\r\n\t\t\tname,\r\n\t\t\tmsg.sender,\r\n\t\t\tattestationUID,\r\n\t\t\tlocation,\r\n\t\t\tdescription,\r\n\t\t\tprice,\r\n\t\t\tbeds,\r\n\t\t\tcid\r\n\t\t);\r\n\t\tlistings.push(listing);\r\n\r\n\t\texistingIds[currentId] = true;\r\n\t\tidToIndex[listing.id] = currentId;\r\n\t\tcurrentId++;\r\n\r\n\t\temit AddListing(msg.sender, listing.id);\r\n\t}\r\n\r\n\tfunction updateListing(\r\n\t\tuint256 id,\r\n\t\tstring calldata name,\r\n\t\tstring calldata location,\r\n\t\tstring calldata description,\r\n\t\tuint256 price,\r\n\t\tuint256 beds\r\n\t) public checkExistedListingId(id) isSeller(id) {\r\n\t\tuint256 index = idToIndex[id];\r\n\r\n\t\t// Only update fields that are not empty or zero\r\n\t\tif (bytes(name).length > 0) {\r\n\t\t\tlistings[index].name = name;\r\n\t\t}\r\n\t\tif (bytes(location).length > 0) {\r\n\t\t\tlistings[index].location = location;\r\n\t\t}\r\n\t\tif (bytes(description).length > 0) {\r\n\t\t\tlistings[index].description = description;\r\n\t\t}\r\n\t\tif (price > 0) {\r\n\t\t\tlistings[index].price = price;\r\n\t\t}\r\n\t\tif (beds > 0) {\r\n\t\t\tlistings[index].beds = beds;\r\n\t\t}\r\n\r\n\t\temit UpdateListing(msg.sender, id, name);\r\n\t}\r\n\r\n\tfunction deleteListing(\r\n\t\tuint256 id\r\n\t) public checkExistedListingId(id) isSeller(id) {\r\n\t\tuint256 index = idToIndex[id];\r\n\r\n\t\tfor (uint256 i = index; i < listings.length - 1; i++) {\r\n\t\t\tlistings[i] = listings[i + 1];\r\n\t\t\tidToIndex[listings[i].id] = i;\r\n\t\t}\r\n\t\tlistings.pop();\r\n\r\n\t\tdelete existingIds[id];\r\n\t\tdelete idToIndex[id];\r\n\r\n\t\temit DeleteListing(msg.sender, id);\r\n\t}\r\n\r\n\tfunction createListingConnection(\r\n\t\tuint256 listingId\r\n\t) public checkExistedListingId(listingId) returns (bytes32 attestationUID) {\r\n\t\tif (connectedBuyers[listingId][msg.sender]) {\r\n\t\t\trevert Listings__BuyerAlreadyConnected(msg.sender, listingId);\r\n\t\t}\r\n\r\n\t\tconnectedBuyers[listingId][msg.sender] = true;\r\n\t\tattestationUID = _listingConnectionAttester.attestListingConnection(\r\n\t\t\tlistingId,\r\n\t\t\tlistings[idToIndex[listingId]].seller,\r\n\t\t\tmsg.sender\r\n\t\t);\r\n\t\temit CreateListingConnection(msg.sender, listingId);\r\n\t}\r\n\r\n\tfunction getAllListings()\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (Listing[] memory allListings)\r\n\t{\r\n\t\treturn listings;\r\n\t}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}